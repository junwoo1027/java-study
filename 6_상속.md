## 자바 상속의 특징
상속 : 기존의 클래스를 재사용하여 새로운 클래스를 만드는 일  
특징
- 적은 양의 코드로 새로운 클래스를 작성할 수 있다. -> 코드의 재사용성 및 중복코드 제거
- 코드의 추가 및 변경이 쉽다. -> 유지보수
- 자바는 클래스를 구현할 때 상속을 최대 1번만 할 수 있다. (다중 상속X)
- 생성자와 초기화 블럭은 상속되지 않는다.
- Object 클래스는 모든 클래스의 부모 클래스이다.

```java
public class People {
    String name;
}

class Student extends People {

}
```

## super 키워드
부모의 기본 생성자를 호출하는 역할(반드시 자식 생성자의 첫 줄에 위치)  
자바는 자식 객체를 생성하면 부모 객체가 먼저 생성되고 자식 객체는 그 다음에 생성된다.  

객체를 생성하려면 생성자를 호출해야 하는데 자식 생성자의 맨 첫 줄에서 부모 클래스의 생성자가 호출된다. 자식클래스의 생성자를 명시적으로 선언하지 않았다면
컴파일러가 자동으로 다음과 같은 기본 생성자를 생성한다.

```java
public Student() {
    super();
}
```

부모 클래스에 기본 생성자가 없고 매개변수를 갖는 생성자만 있다면 자식 클래스에서 반드시 super(매개값, ..);를 직접 명시한다.  

```java
public class People {
    String name;

    public People(String name) {
        this.name = name;
    }
}

class Student extends People {

    int studentNum;

    public Student(String name, int studentNum) {
//        super(name);
        this.studentNum = studentNum;
    }
}
```
super(name);를 작성하지 않은 경우 컴파일 에러가 발생한다.

## 메소드 오버라이딩
메소드를 오버라이딩하면 자식 객체 메소드 호출 시 부모 기능은 숨겨지고 자식이 재정의한 기능 실행

```java
public class Parent {

    void method1() {
        System.out.println("부모 메소드1 호출");
    }
    void method2() {
        System.out.println("부모 메소드2 호출");
    }
}


class Child extends Parent {

    @Override
    void method2() {
        System.out.println("자식 메소드2 호출");
    }

    void method3() {
        System.out.println("자식 메소드3 호출");
    }
}
```

```java
class Example {
    public static void main(String[] args) {
        Child child = new Child();

        child.method1(); //부모 메소드1 호출
        child.method2(); // 자식 메소드2 호출
        child.method3(); //자식 메소드3 호출
    }
}
```
### 오버라이딩 할 때 주의할 점
1. 부모 메소드와 메소드 이름, 매개변수 리스트가 동일해야한다.
2. 부모 메소드의 접근 제한자보다 강한 제한 사용 불가능
- 부모 : public -> 자식 : public 가능
- 부모 : default -> 자식 : public, protected, default 가능
3. 새로운 예외 추가 불가능

## 메소드 디스패치(Method Dispatch)
